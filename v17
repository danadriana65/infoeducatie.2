import tkinter as tk
from tkinter import PhotoImage
from tkVideoPlayer import TkinterVideo  # Ensure this library is installed
from tkinter import Canvas
from tkinter import messagebox  # Import pentru popup-uri
from tkinter import filedialog
from PIL import Image, ImageTk
from PIL import Image, ImageTk, ImageDraw
import os
import sys
import json  
import smtplib
from email.mime.text import MIMEText
from functools import partial
import pandas as pd
from pathlib import Path
import bcrypt

# Define a global variable to store the username
user_input = ""
root = tk.Tk()
root.geometry('900x600')  # Adjust for practical size
root.title('Welcome to app!')


def get_asset_path(filename):
    """
    Returns the path of a file, whether the script is run normally or packaged with PyInstaller.
    """
    if hasattr(sys, "_MEIPASS"):
        # PyInstaller's temp directory
        return os.path.join(sys._MEIPASS, filename)
    return filename

def play_video():
    for widget in root.winfo_children():
        widget.destroy()
    default_video_path = get_asset_path(r"C:\Users\Adriana\Desktop\grid\WhatsApp Video 2025-03-31 at 12.10.50_af799974.mp4")  # Place the default video file in the same directory
    if not os.path.exists(default_video_path):
        messagebox.showerror("Error", "Default video file not found! Please select a file.")
        file_path = filedialog.askopenfilename(filetypes=[("Video Files", "*.mp4")])
        if file_path:
            default_video_path = file_path
        else:
            return
    # Create video player
    videoplayer = TkinterVideo(master=root, scaled=True)
    videoplayer.load(r"C:\Users\Adriana\Desktop\grid\WhatsApp Video 2025-03-31 at 12.10.50_af799974.mp4") 
    videoplayer.pack()
    videoplayer.place(relx=0.5, rely=0.5, anchor="center", width=1550, height=791)  # Exemplu pentru 400x300 # Replace with your video file path
    videoplayer.play()

    # Schedule transition to grid after video ends
    videoplayer.bind("<<Ended>>", lambda e: show_grid())

def show_grid():
    global user_input
    global username, password, your_email
    background_video_path =get_asset_path(r"C:\Users\Adriana\Desktop\grid\WhatsApp Video 2025-04-05 at 20.39.03_78657a3f.mp4")  # Default video file for background
    if not os.path.exists(background_video_path):
        messagebox.showerror("Error", "Background video file not found! Please select a file.")
        file_path = filedialog.askopenfilename(filetypes=[("Video Files", "*.mp4")])
        if file_path:
            background_video_path = file_path
        else:
            return
    for widget in root.winfo_children():
        widget.destroy()

    # Create a canvas to hold the video background
    canvas = Canvas(root)
    canvas.place(relwidth=1, relheight=1)

    # Load and play video as background
    videoplayer = TkinterVideo(master=canvas, scaled=True)
    videoplayer.load(r"C:\Users\Adriana\Desktop\grid\WhatsApp Video 2025-04-05 at 20.39.03_78657a3f.mp4")  # Replace with your video file path
    videoplayer.pack(expand=True, fill="both")
    videoplayer.play()

    # Loop the video after it ends
    videoplayer.bind("<<Ended>>", lambda e: videoplayer.play())

    # Form elements placed on top of the video
    container = tk.Frame(root, bg='#711adf')
    container.place(relx=0.5, rely=0.5, anchor=tk.CENTER)

    title0 = tk.Label(container, text="Welcome to Cosmiccode!", font=('Gill Sans Ultra Bold', 24), fg='#1b219d', bg='#711adf')
    title0.grid(row=0, column=0, columnspan=2, padx=10, pady=10, sticky="n")

    title1 = tk.Label(container, text="Enter your username and password and let's start a cosmic game!", font=('Gill Sans Ultra Bold', 15), fg='#1b219d', bg='#711adf', wraplength=400)
    title1.grid(row=1, column=0, columnspan=2, padx=10, pady=10, sticky="n")

    user_label = tk.Label(container, text='Username', font=('Gill Sans Ultra Bold', 15), fg='#1b219d', bg='#711adf')
    user_label.grid(row=2, column=0, padx=5, pady=5, sticky="e")

    username = tk.Entry(container, font=('Arial', 15), fg='white', bg='#180451')
    username.grid(row=2, column=1, padx=5, pady=5, sticky="w")

    user_email = tk.Label(container, text='Your e-mail', font=('Gill Sans Ultra Bold', 15), fg='#1b219d', bg='#711adf')
    user_email.grid(row=3, column=0, padx=5, pady=5, sticky="e")

    your_email = tk.Entry(container, font=('Arial', 15), fg='white', bg='#180451')
    your_email.grid(row=3, column=1, padx=5, pady=5, sticky="w")

    user_password = tk.Label(container, text='Password', font=('Gill Sans Ultra Bold', 15), fg='#1b219d', bg='#711adf')
    user_password.grid(row=4, column=0, padx=5, pady=5, sticky="e")

    password = tk.Entry(container, font=('Arial', 15), fg='white', bg='#180451', show='*')
    password.grid(row=4, column=1, padx=5, pady=5, sticky="w")
    
    submit = tk.Button(container, text='CreazÄƒ Cont', font=('Gill Sans Ultra Bold', 15), fg='white', bg='#180451', command=submit_username)
    submit.grid(row=5, column=0, columnspan=2, padx=10, pady=20, sticky="ew")
    login_button = tk.Button(container, text='Login', font=('Gill Sans Ultra Bold', 15), fg='white', bg='#180451', command=login)
    login_button.grid(row=6, column=0, columnspan=2, padx=10, pady=20, sticky="ew")

    sign_out_button = tk.Button(
    root,
    text="Sign Out",
    font=('Gill Sans Ultra Bold', 12),
    fg='white',
    bg='#180451',
    command=sign_out
)
    sign_out_button.pack(side=tk.BOTTOM, padx=10, pady=5)

# FuncÈ›ie pentru salvarea datelor utilizatorului Ã®n JSON

def sign_out():
    global user_input, user_mail
    user_input = ""
    user_mail = ""

    # È˜tergem utilizatorul curent din JSON
    user_data = load_user_data()
    if user_input in user_data:
        del user_data[user_input]  # EliminÄƒm doar utilizatorul curent

        # SalvÄƒm datele actualizate
        with open("user_date.json", "w") as f:
            json.dump(user_data, f, indent=4)

    # ResetÄƒm cÃ¢mpurile de autentificare
    username.delete(0, tk.END)
    your_email.delete(0, tk.END)
    password.delete(0, tk.END)

    # ReÃ®ncÄƒrcÄƒm pagina de login
    show_grid()

def load_user_data():
    try:
        with open("user_credentials.json", "r") as f:
            data = json.load(f)
            return data if data else {}  # DacÄƒ fiÈ™ierul e gol, returneazÄƒ un dicÈ›ionar gol
    except (FileNotFoundError, json.JSONDecodeError):
        return {}  # DacÄƒ fiÈ™ierul nu existÄƒ sau nu se poate citi, iniÈ›ializÄƒm un dicÈ›ionar gol


def store_user_info(username, password, email):
    user_data = load_user_data()  # ÃŽncÄƒrcÄƒm datele existente
    
    if username in user_data:
        messagebox.showerror("Eroare", "Utilizatorul existÄƒ deja! ÃŽncearcÄƒ sÄƒ te autentifici.")
    else:
        user_data[username] = {"password": password, "email": email}

        with open("user_credentials.json", "w") as f:
            json.dump(user_data, f, indent=4)

        messagebox.showinfo("Succes", "Contul a fost creat!")

def verify_user(username, password):
    user_data = load_user_data()

    if username not in user_data:
        return False  # Username-ul nu existÄƒ
    if "password" not in user_data[username]:
        return False  # Parola nu este salvatÄƒ corect

    return user_data[username]["password"] == password


def submit_username():
    global user_mail
    global user_input
    entered_username = username.get().strip()
    entered_password = password.get().strip()
    entered_email = your_email.get().strip()

    if not entered_username or not entered_password or not entered_email:
        messagebox.showerror("Eroare de Autentificare", "AutentificÄƒ-te!")
    else:
        store_user_info(entered_username, entered_password, entered_email)
        user_mail = entered_email  # SetÄƒm email-ul utilizatorului
        user_input = entered_username   # Modificat aici
        messagebox.showinfo("Succes", "Contul a fost creat!")
        on_submit()  

def login():
    global user_mail, user_input
    entered_username = username.get().strip()
    entered_password = password.get().strip()

    user_data = load_user_data()  # âœ… ÃŽncÄƒrcÄƒm datele salvate

    if entered_username in user_data:
        if verify_user(entered_username, entered_password):
            messagebox.showinfo("Autentificare reuÈ™itÄƒ", "Te-ai conectat cu succes!")
            user_mail = user_data[entered_username]["email"]  # SetÄƒm email-ul
            user_input = entered_username
            on_submit()
        else:
            messagebox.showerror("Eroare", "ParolÄƒ incorectÄƒ! ÃŽncearcÄƒ din nou.")
            password.delete(0, tk.END)  
    else:
        messagebox.showerror("Eroare", "Nu existÄƒ acest cont! CreeazÄƒ unul mai Ã®ntÃ¢i.")


def on_submit():
    for widget in root.winfo_children():
        widget.destroy()
    canvas = Canvas(root)
    canvas.place(relwidth=1, relheight=1)
    
    default_video_path = get_asset_path(r"C:\Users\Adriana\Desktop\grid\WhatsApp Video 2025-04-05 at 20.39.03_78657a3f.mp4")
    if not os.path.exists(default_video_path):
        # Prompt the user to select a file if missing
        messagebox.showerror("Error", "Background video file not found! Please select a file.")
        file_path = filedialog.askopenfilename(filetypes=[("Video Files", "*.mp4")])
        if file_path:
            default_video_path = file_path
        else:
            return
    # Load and play video as background
    videoplayer = TkinterVideo(master=canvas, scaled=True)
    videoplayer.load(r"C:\Users\Adriana\Desktop\grid\WhatsApp Video 2025-04-05 at 20.39.03_78657a3f.mp4")  # Replace with your video file path
    videoplayer.pack(expand=True, fill="both")
    videoplayer.play()

    # Loop the video after it ends
    videoplayer.bind("<<Ended>>", lambda e: videoplayer.play())
    # Frame for coding options
    options_frame = tk.Frame(root, bg='#711adf')
    options_frame.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
    options_label = tk.Label(options_frame, text="Learn to code in...", font=('Gill Sans Ultra Bold', 24), fg='#1b219d', bg='#711adf')
    options_label.pack(pady=20)
    
    # Stickers for buttons
    cplusplus_sticker = PhotoImage(file=r"C:\Users\Adriana\Desktop\grid\ISO_C++_Logo.svg(1).png")  # Replace with your sticker file path
    python_sticker = PhotoImage(file=r"C:\Users\Adriana\Desktop\grid\Python.svg(1).png")        # Replace with your sticker file path
    javascript_sticker = PhotoImage(file=r"C:\Users\Adriana\Desktop\grid\1698604163003(1).png")# Replace with your sticker file path

    # Options with stickers
    options = [
        ("C++", cplusplus_sticker),
        ("Python", python_sticker),
        ("JavaScript", javascript_sticker),
    ]

    button_width = 250
    button_height = 50
    
    for option, sticker in options:
        option_button = tk.Button(
            options_frame,
            text=option,
            font=('Gill Sans Ultra Bold', 14),
            fg='white',
            bg='#180451',
            image=sticker,  # Add the sticker
            compound=tk.LEFT,  # Place the sticker on the left side of the button text
            command=lambda opt=option: navigate_to_page(opt),
            width=button_width,
            height=button_height
        )
        option_button.image = sticker  # Keep a reference to prevent garbage collection
        option_button.pack(pady=10)

    # Undo button
    undo_button = tk.Button(root, text="Undo", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#180451', command=show_grid)
    undo_button.place(relx=0.1, rely=0.1, anchor=tk.CENTER)

    # Settings button
    settings_button = tk.Button(root, text="Settings", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#180451', command=open_settings_window)
    settings_button.place(relx=0.9, rely=0.1, anchor=tk.CENTER)


def navigate_to_page(option):
    for widget in root.winfo_children():
        widget.destroy()
    background_video_path = get_asset_path(r"C:\Users\Adriana\Desktop\grid\WhatsApp Video 2025-04-05 at 20.39.03_78657a3f.mp4")
    if not os.path.exists(background_video_path):
        messagebox.showerror("Error", "Background video file not found! Please select a file.")
        file_path = filedialog.askopenfilename(filetypes=[("Video Files", "*.mp4")])
        if file_path:
            background_video_path = file_path
        else:
            return
    # Background for planet buttons
    canvas = Canvas(root)
    canvas.place(relwidth=1, relheight=1)

    # Load and play video as background
    videoplayer = TkinterVideo(master=canvas, scaled=True)
    videoplayer.load(r"C:\Users\Adriana\Desktop\grid\WhatsApp Video 2025-04-05 at 20.39.03_78657a3f.mp4")  # Replace with your video file path
    videoplayer.pack(expand=True, fill="both")
    videoplayer.play()

    # Loop the video after it ends
    videoplayer.bind("<<Ended>>", lambda e: videoplayer.play())

    top_bar = tk.Frame(root, bg='#711adf', height=50)
    top_bar.pack(side=tk.TOP, fill=tk.X)

    # Add three buttons to the top bar
    button1 = tk.Button(top_bar, text="Progress", font=('Gill Sans Ultra Bold', 12), fg='white', bg='#180451', command=show_progress)
    button1.pack(side=tk.LEFT, padx=10, pady=5)

    button2 = tk.Button(top_bar, text="LeaderBoard", font=('Gill Sans Ultra Bold', 12), fg='white', bg='#180451', command=show_leaderboard)
    button2.pack(side=tk.LEFT, padx=20, pady=5)

    button3 = tk.Button(top_bar, text="Profile", font=('Gill Sans Ultra Bold', 12), fg='white', bg='#180451', command=open_profile_window)
    button3.pack(side=tk.LEFT, padx=50, pady=5)
    # Example planet images
    planet_images = {
        "Uranus": PhotoImage(file=r"C:\Users\Adriana\Desktop\grid\WhatsApp Image 2025-03-15 at 22.57.57_426e474f1.2.png"),  # Replace paths
        "Venus": PhotoImage(file=r"C:\Users\Adriana\Desktop\grid\WhatsApp Image 2025-03-15 at 22.57.57_426e474f.3.png"),
        "Saturn": PhotoImage(file=r"C:\Users\Adriana\Desktop\grid\WhatsApp Image 2025-03-15 at 22.57.57_426e474f.4.png"),}

    # Add planet buttons directly on the background image
    column = 0
    for planet_name, planet_image in planet_images.items():
        if option == "Python":
            planet_button_command = lambda name=planet_name: show_new_options_page(name, option)
        elif option == "C++":
            planet_button_command = lambda name=planet_name: show_new_options_page(name, option)
        else:
            planet_button_command = lambda name=planet_name: show_new_options_page(name, None)
        planet_button = tk.Button(
            root,
            image=planet_image,
           command=lambda name=planet_name, option=option: show_new_options_page(name, option),    # Navigate to new options page
            borderwidth=0,
            bg='#711adf',
            activebackground='#711adf'
        )
        planet_button.image = planet_image  # Keep a reference
        planet_button.place(relx=0.3 + (column * 0.2), rely=0.5, anchor=tk.CENTER)  # Adjust placement
        column += 1

    # Undo button
    message_label = tk.Label(root, text=f"You selected {option}. Explore planets below!", font=('Gill Sans Ultra Bold', 20), fg='#1b219d', bg='#711adf')
    message_label.place(relx=0.5, rely=0.85, anchor=tk.CENTER)

    undo_button = tk.Button(
        root,
        text="Undo",
        font=('Gill Sans Ultra Bold', 12),
        fg='white',
        bg='#180451',
        command=on_submit
    )
    undo_button.place(relx=0.1, rely=0.1, anchor=tk.CENTER)


def show_new_options_page(planet_name, selected_option):
    for widget in root.winfo_children():
        widget.destroy()

    # Set a background for the new page
    bg_image = tk.Label(root, image=grid_image_path)
    bg_image.place(relheight=1, relwidth=1)
    
    # Display title
    title_label = tk.Label(
        bg_image,
        text=f"Options for {planet_name}",
        font=('Gill Sans Ultra Bold', 20),
        fg='white',
        bg='#a924f0'
    )
    title_label.pack(pady=20)
    buttons_frame = tk.Frame(root, bg='#a924f0')
    buttons_frame.pack(pady=80)
    # Generate 7 dynamic buttons
    for i in range(7):
        if planet_name == "Uranus" and selected_option == "Python":
            button_command = partial(show_question_page, planet_name, selected_option, questions[i], answers[i], correct_answers[i])
        elif planet_name == "Venus" and selected_option == "Python":
            button_command = partial(show_question_page, planet_name, selected_option, questions_python_b[i], answers_python_b[i], correct_answers_python_b[i])
        elif planet_name == "Saturn" and selected_option == "Python":
            button_command = partial(show_question_page_with_code, planet_name, selected_option, questions_python_c[i], code_samples_python_c[i], answers_python_c[i], correct_answers_python_c[i])
        elif planet_name == "Uranus" and selected_option == "JavaScript":
            button_command = partial(show_question_page, planet_name, selected_option, questions_javascript_a[i], answers_javascript_a[i], correct_answers_javascript_a[i])
        elif planet_name == "Venus" and selected_option == "JavaScript":
            button_command = partial(show_question_page, planet_name, selected_option, questions_javascript_code[i], answers_javascript_code[i], correct_answers_javascript_code[i])
        elif planet_name == "Saturn" and selected_option == "JavaScript":
            button_command = partial(show_question_page_with_code, planet_name, selected_option, questions_python_c[i], code_samples_python_c[i], answers_python_c[i], correct_answers_python_c[i])
        elif planet_name == "Uranus" and selected_option == "C++":
            button_command = partial(show_question_page, planet_name, selected_option, questions_cpp[i], answers_cpp[i], correct_answers_cpp[i])
        elif planet_name == "Venus" and selected_option == "C++":
            button_command = partial(show_question_page, planet_name, selected_option, questions_cpp_code[i], answers_cpp_code[i], correct_answers_cpp_code[i])
        elif planet_name == "Saturn" and selected_option == "C++":
            button_command = partial(show_question_page_with_code, planet_name, selected_option, questions_cpp1[i], code_cpp1[i], answers_cpp1[i],correct_answers_cpp1[i])
        else:
            button_command = lambda: print(f"ExerciÈ›iu {i + 1} selectat pentru {planet_name}, dar fÄƒrÄƒ Ã®ntrebÄƒri.")
        button = tk.Button(buttons_frame, text=f"ExerciÈ›iu {i + 1}", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#180451',width=15, height=2, command=button_command)
        button.grid(row=i//2, column=i%2, padx=20, pady=30)  # 2 coloane
        

    # Buton "ÃŽnapoi" care revine la pagina principalÄƒ
    back_button = tk.Button(
       bg_image,
        text="Undo",
        font=('Gill Sans Ultra Bold', 15),
        fg='white',
        bg='#a924f0',
        command=lambda: on_submit()
    )
    back_button.place(relx=0.2, rely=0.2, anchor=tk.CENTER)

def save_user_data(data):
    with open("user_data.json", "w") as f:
        json.dump(data, f)

def load_user_data():
    try:
        with open("user_data.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

# Initialize user data
user_data = load_user_data()
questions_cpp1 = [
    "Care dintre urmÄƒtoarele declarÄƒ corect o funcÈ›ie Ã®n Python?",
    "Care dintre urmÄƒtoarele este sintaxa corectÄƒ pentru un `for loop`?",
    "Care este modul corect de a accesa un element dintr-o listÄƒ?",
    "Care dintre urmÄƒtoarele alocÄƒ corect memorie dinamicÄƒ?",
    "Care dintre urmÄƒtoarele clase implementeazÄƒ corect moÈ™tenirea?",
    "Care este forma corectÄƒ de a citi un numÄƒr de la tastaturÄƒ?",
    "Care dintre urmÄƒtoarele defineÈ™te corect un destructor?"
]

# Vectorul de cod Python asociat fiecÄƒrei Ã®ntrebÄƒri
code_cpp1 = [
    "def my_function():\n    pass",
    "for i in range(n):\n    print(i)",
    "my_list = [1, 2, 3]\nprint(my_list[2])",
    "import numpy as np\narr = np.zeros(5)",
    "class Child(Parent):\n    pass",
    "x = int(input(\"Introdu un numÄƒr: \"))",
    "class MyClass:\n    def __del__(self):\n        print(\"Destructor apelat\")"
]
answers_cpp1 = [
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 2", "Linia 3", "Linia 1", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"]
]

correct_answers_cpp1 = [
    "Linia 1",
    "Linia 1",
    "Linia 1",
    "Linia 2",
    "Linia 1",
    "Linia 2",
    "Linia 3"
]
questions_cpp_code = [
    "Care dintre urmÄƒtoarele declarÄƒ corect o funcÈ›ie Ã®n C++?",
    "Care dintre urmÄƒtoarele este sintaxa corectÄƒ pentru un `for loop`?",
    "Care este modul corect de a accesa un element dintr-un vector?",
    "Care dintre urmÄƒtoarele alocÄƒ corect memorie dinamicÄƒ?",
    "Care dintre urmÄƒtoarele clase implementeazÄƒ corect moÈ™tenirea?",
    "Care este forma corectÄƒ de a citi un numÄƒr de la tastaturÄƒ?",
    "Care dintre urmÄƒtoarele defineÈ™te corect un destructor?"
]

answers_cpp_code = [
    ["function myFunction();", "void myFunction();", "func myFunction();"],
    ["for (i = 0; i < n; i++)", "for i in range(0, n)", "loop (i; i < n; i++)"],
    ["vector[2]", "vector(2)", "vector -> 2"],
    ["alloc<int> ptr;", "int ptr = malloc(sizeof(int));", "int *ptr = new int;"],
    ["class Child : Parent {}", "class Parent -> Child {}", "inherit Parent -> Child {}"],
    ["cin >> x;", "input(x);", "x = scan();"],
    ["~MyClass() {}", "destructor MyClass() {}", "destroy MyClass();"]
]

correct_answers_cpp_code = [
    "void myFunction();",
    "for (i = 0; i < n; i++)",
    "vector[2]",
    "int *ptr = new int;",
    "class Child : Parent {}",
    "cin >> x;",
    "~MyClass() {}"
]

questions_cpp = [
    "Care dintre urmÄƒtoarele este un mod corect de a declara o variabilÄƒ Ã®n C++?",
    "Ce cuvÃ¢nt-cheie folosim pentru a aloca dinamic memorie Ã®n C++?",
    "Ce tip de date folosim pentru a stoca un singur caracter Ã®n C++?",
    "Care dintre urmÄƒtoarele bucle NU existÄƒ Ã®n C++?",
    "Care dintre urmÄƒtoarele operatori este folosit pentru accesarea membrilor unei structuri sau clase?",
    "Care este scopul funcÈ›iei `main()` Ã®n C++?",
    "Ce se Ã®ntÃ¢mplÄƒ cÃ¢nd apelÄƒm `delete` pe un pointer valid?"
]

answers_cpp = [
    ["int x;", "variable x;", "x = 5;", "declare x;"],
    ["alloc", "new", "malloc", "allocate"],
    ["char", "string", "character", "text"],
    ["for", "while", "repeat-until", "do-while"],
    [".", "->", "*", "&"],
    ["IniÈ›ializarea tuturor variabilelor", "Stabilirea punctului de intrare al programului", "AfiÈ™area rezultatelor", "Crearea de obiecte"],
    ["Memoria asociatÄƒ cu pointerul este eliberatÄƒ", "Pointerul se È™terge automat din cod", "Programul se opreÈ™te imediat", "Pointerul este resetat la zero"]
]

correct_answers_cpp = [
    "int x;", "new", "char", "repeat-until", ".", "Stabilirea punctului de intrare al programului", "Memoria asociatÄƒ cu pointerul este eliberatÄƒ"
]

questions = [
    "Ce este metoda __new__() Ã®n Python?",
    "Ce face @staticmethod Ã®n Python?",
    "Care este diferenÈ›a dintre deepcopy() È™i copy()?",
    "Ce va returna list(map(lambda x: x**2, range(3)))?",
    'Ce face expresia if __name__ == "__main__": Ã®n Python?',
    "Care dintre urmÄƒtoarele NU este o metodÄƒ validÄƒ pentru sincronizarea thread-urilor Ã®n Python?",
    "Ce rezultat va avea print(bool([]) == False)?" ]
  

answers = [
    ["O metodÄƒ care creeazÄƒ o instanÈ›Äƒ Ã®nainte de __init__()", "O metodÄƒ folositÄƒ doar Ã®n moÈ™tenirea multiplÄƒ", "O metodÄƒ specialÄƒ care returneazÄƒ self", "O metodÄƒ de conversie Ã®ntre tipuri de date"],
    ["CreeazÄƒ o metodÄƒ care poate fi apelatÄƒ doar de alte clase", "DefineÈ™te o metodÄƒ staticÄƒ care nu are acces la self", "Permite accesul la metodele private din clasÄƒ", "TransformÄƒ metoda Ã®ntr-o variabilÄƒ de clasÄƒ"],
    ["deepcopy() face conversia tipurilor de date", "copy() eliminÄƒ referinÈ›ele cÄƒtre obiectele originale", "deepcopy() este mai rapid decÃ¢t copy()", "copy() creeazÄƒ o copie superficialÄƒ, iar deepcopy() copiazÄƒ recursiv obiectele"],
    ["[1, 4, 9]", "[0, 2, 4]", "[0, 1, 4]", "[1, 2, 3]"],
    ["CreeazÄƒ o variabilÄƒ globalÄƒ numitÄƒ __main__", "Permite executarea Ã®n paralel a mai multor funcÈ›ii", "DeterminÄƒ dacÄƒ scriptul este executat direct", "VerificÄƒ dacÄƒ scriptul este importat din alt modul"],
    ["threading.Event()", "threading.pause()", "threading.Lock()", "threading.Semaphore()"],
    ["True", "False", "Va genera o eroare", "None"]
]

correct_answers = ["O metodÄƒ care creeazÄƒ o instanÈ›Äƒ Ã®nainte de __init__()", "DefineÈ™te o metodÄƒ staticÄƒ care nu are acces la self", "copy() creeazÄƒ o copie superficialÄƒ, iar deepcopy() copiazÄƒ recursiv obiectele", "[0, 1, 4]", "DeterminÄƒ dacÄƒ scriptul este executat direct", "threading.pause()", "True"]
questions_javascript_a = [
    "Cum declarÄƒm o variabilÄƒ Ã®n JavaScript?",
    "Care dintre urmÄƒtoarele NU este un mod valid de a declara o funcÈ›ie?",
    "Cum verificÄƒm tipul unei variabile Ã®n JavaScript?",
    "Ce va afiÈ™a `console.log(2 + '2')`?",
    "Care dintre urmÄƒtoarele structuri de date NU existÄƒ Ã®n JavaScript?",
    "Cum iterÄƒm peste un array folosind `map()`?",
    "Cum facem o copie superficialÄƒ a unui obiect Ã®n JavaScript?"
]

answers_javascript_a = [
    ["var x = 10;", "let x = 10;", "const x = 10;", "int x = 10;"],
    ["function myFunc() {}", "const myFunc = function() {}", "myFunc = () => {}", "def myFunc() {}"],
    ["typeof x", "x.type()", "getType(x)", "x.kind"],
    ["22", "'22'", "4", "Error"],
    ["Array", "Set", "Tuple", "Map"],
    ["array.map(x => x * 2)", "map(array, x => x * 2)", "array.map(function(x) { return x * 2 })", "array.forEach(x => x * 2)"],
    ["Object.assign({}, obj)", "obj.copy()", "{...obj}", "clone(obj)"]
]

correct_answers_javascript_a = [
    "int x = 10;",  # Varianta greÈ™itÄƒ (to test knowledge)
    "def myFunc() {}",  # Varianta greÈ™itÄƒ (nu existÄƒ Ã®n JS)
    "typeof x",
    "'22'",
    "Tuple",
    "array.map(x => x * 2)",
    "{...obj}"
]
questions_javascript_code = [
    "Cum declarÄƒm o funcÈ›ie anonimÄƒ Ã®n JavaScript?",
    "Care este sintaxa corectÄƒ pentru Arrow Function?",
    "Cum definim un obiect JavaScript?",
    "Care este modul corect de a itera printr-o listÄƒ cu `forEach`?",
    "Cum verificÄƒm dacÄƒ un element existÄƒ Ã®ntr-un array?",
    "Cum facem destructurarea unui obiect?",
    "Cum adÄƒugÄƒm un nou element Ã®ntr-un array?"
]

answers_javascript_code = [
    ["let func = function() {}", "let func() {}", "function = func() {}"],
    ["const add = (a, b) => a + b;", "add = (a, b) { return a + b; }", "function add(a, b) => a + b;"],
    ["let obj = object { name: 'Alex', age: 25 };", "object obj = { 'name': 'Alex', 'age': 25 }", "const obj = { name: 'Alex', age: 25 }"],
    ["array.forEach(item => console.log(item));", "for (item in array) { console.log(item); }", "array.each(item => console.log(item));"],
    ["array.has(5)", "array.includes(5)", "array.exists(5)"],
    ["const { name, age } = obj;", "destructure(obj).get('name', 'age');", "let name, age = obj.extract();"],
    ["array.add('newItem')", "array.push('newItem')", "array.insert('newItem')"]
]

correct_answers_javascript_code = [
    "let func = function() {}",
    "const add = (a, b) => a + b;",
    "const obj = { name: 'Alex', age: 25 }",
    "array.forEach(item => console.log(item));",
    "array.includes(5)",
    "const { name, age } = obj;",
    "array.push('newItem')"
]
questions_javascript_error = [
    "Unde este eroarea de sintaxÄƒ?",
    "ÃŽn ce linie apare eroarea de tip?",
    "Unde se aflÄƒ eroarea de referinÈ›Äƒ?",
    "Pe ce linie se aflÄƒ eroarea de index?",
    "Unde apare eroarea de funcÈ›ie nedefinitÄƒ?",
    "Pe ce linie este eroarea de acces la obiect?",
    "ÃŽn ce linie este eroarea de scoping?"
]

code_samples_javascript_error = [
    "console.log('Hello World'\nconsole.log('JS Error')",   # LipsÄƒ parantezÄƒ Ã®nchidere
    "let x = 'text' + 5;\nconsole.log(x);",                # Concatenare greÈ™itÄƒ
    "console.log(y);\nlet y = 10;",                         # VariabilÄƒ folositÄƒ Ã®nainte de declarare
    "let array = [1, 2, 3];\nconsole.log(array[5]);",       # Acces invalid la index
    "myFunction();\nfunction notDeclared() { console.log('Error') }",  # Apelare Ã®nainte de definire
    "let obj = { name: 'Alice' };\nconsole.log(obj.age.length);",      # Acces invalid la proprietÄƒÈ›i
    "function test() {\n    let x = 10;\n}\nconsole.log(x);"  # VariabilÄƒ Ã®n afara scoping-ului funcÈ›iei
]

answers_javascript_error = [
    ["Linia 2", "Linia 1", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 3", "Linia 2", "Linia 1", "Nicio eroare"],
    ["Linia 2", "Linia 3", "Linia 1", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"]
]

correct_answers_javascript_error = [
    "Linia 1",
    "Linia 1",
    "Linia 1",
    "Linia 2",
    "Linia 1",
    "Linia 2",
    "Linia 3"
]

user_progress = {
    "Python": {"Uranus": 0, "Venus": 0, "Saturn": 0},
    "JavaScript": {"Uranus": 0, "Venus": 0, "Saturn": 0},
    "C++": {"Uranus": 0, "Venus": 0, "Saturn": 0}
}

# FuncÈ›ie de salvare a progresului Ã®n JSON
def save_progress():
    with open("user_progress.json", "w") as f:
        json.dump(user_progress, f, indent=4)

# FuncÈ›ie de Ã®ncÄƒrcare a progresului din JSON
def load_progress():
    try:
        with open("user_progress.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return user_progress  # DacÄƒ fiÈ™ierul nu existÄƒ, foloseÈ™te progresul iniÈ›ial
def reset_progress():
    global user_progress
    user_progress = {
        "Python": {"Uranus": 0, "Venus": 0, "Saturn": 0},
        "JavaScript": {"Uranus": 0, "Venus": 0, "Saturn": 0},
        "C++": {"Uranus": 0, "Venus": 0, "Saturn": 0}
    }  # ResetÄƒm progresul

    with open("user_progress.json", "w") as f:
        json.dump(user_progress, f, indent=4)  # SalvÄƒm progresul resetat Ã®n fiÈ™ier

    root.destroy()  # ÃŽnchidem aplicaÈ›ia dupÄƒ resetare
  # ÃŽnchidem aplicaÈ›ia dupÄƒ resetare
# ÃŽncÄƒrcÄƒm progresul utilizatorului
user_progress = load_progress()

# ModificÄƒm `handle_answer()` pentru a Ã®nregistra rÄƒspunsurile corecte

def show_leaderboard():
    total_correct = sum(correct_count for planets in user_progress.values() for correct_count in planets.values())

    # DeterminÄƒm premiul
    if total_correct >= 21:
        award = "ðŸ† Aur"
    elif total_correct >= 14:
        award = "ðŸ¥ˆ Argint"
    elif total_correct >= 7:
        award = "ðŸ¥‰ Bronz"
    else:
        award = "ðŸ”¹ FÄƒrÄƒ medalie - mai Ã®ncearcÄƒ!"
    leaderboard_window = tk.Toplevel()
    leaderboard_window.title("Leaderboard")
    leaderboard_window.configure(bg="#002366")
    label = tk.Label(leaderboard_window, text=f"Premiul tÄƒu: {award}\nAi rÄƒspuns corect la {total_correct} Ã®ntrebÄƒri!",
                     font=("Arial", 14), fg="white", bg="#002366")
    label.pack(padx=20, pady=20)
   
# FuncÈ›ie pentru a afiÈ™a progresul utilizatorului
def show_progress():
    progress_window = tk.Toplevel()
    progress_window.title("Progress")
    progress_window.configure(bg="#002366")  # Albastru Ã®nchis

    progress_message = "Progresul tÄƒu:\n"
    for option, planets in user_progress.items():
        progress_message += f"\n{option}:\n"
        for planet, correct_count in planets.items():
            progress_message += f"  {planet}: {correct_count} Ã®ntrebÄƒri corecte\n"

    label = tk.Label(progress_window, text=progress_message,
                     font=("Arial", 14), fg="white", bg="#002366", justify="left")
    label.pack(padx=20, pady=20)
    root.protocol("WM_DELETE_WINDOW", reset_progress)
def play_question_video(video_path, question_function, planet_name, selected_option):
    # CreÄƒm o fereastrÄƒ nouÄƒ de ecran complet
    window_video = tk.Toplevel()
    window_video.attributes('-fullscreen', True)  # SetÄƒm fereastra pe ecran complet
    window_video.title("Videoclip")

    # CreÄƒm playerul video
    video_player = TkinterVideo(master=window_video, scaled=True)
    video_player.load(video_path)
    video_player.pack(fill="both", expand=True)

    # RedÄƒm videoclipul automat
    video_player.play()

    # DetectÄƒm cÃ¢nd videoclipul s-a terminat
    def on_video_end(event):
        window_video.destroy()  # ÃŽnchide fereastra videoclipului
        question_function(planet_name, selected_option)  # Revenim la Ã®ntrebare

    video_player.bind("<<Ended>>", on_video_end)
    # VerificÄƒm manual cÃ¢nd videoclipul s-a terminat (pentru cazuri unde `<<Ended>>` nu funcÈ›ioneazÄƒ)
    def check_video_status():
        if video_player.has_ended():  # DacÄƒ videoclipul s-a terminat
           window_video.destroy()
           question_function(planet_name, selected_option)
        else:
           window_video.after(1000, check_video_status)  # VerificÄƒm periodic

    check_video_status()

# FuncÈ›ie pentru afiÈ™area paginii cu Ã®ntrebÄƒri
def handle_answer(selected_answer, button, planet_name, selected_option, correct_answer):
    global user_progress, buttons  # Acces la variabilele globale
    
    for btn in buttons:
        btn.config(state="disabled")
    if selected_answer == correct_answer:
        button.config(bg="green")
        
        # ContorizÄƒm rÄƒspunsul corect
        if selected_option not in user_progress:
            user_progress[selected_option] = {}
        if planet_name not in user_progress[selected_option]:
            user_progress[selected_option][planet_name] = 0
        
        user_progress[selected_option][planet_name] += 1  # IncrementÄƒm numÄƒrul de rÄƒspunsuri corecte
        save_progress()  # SalvÄƒm progresul utilizatorului

        play_question_video(r"C:\Users\Adriana\infoeducatie.2-1\WhatsApp Video 2025-05-17 at 22.04.13_3d19574a.mp4", show_question_page, planet_name, selected_option)
    else:
        button.config(bg="red")
        play_question_video(r"C:\Users\Adriana\infoeducatie.2-1\WhatsApp Video 2025-05-17 at 22.12.34_8b843c0c.mp4", show_question_page, planet_name, selected_option)

    # DezactivÄƒm toate butoanele din listÄƒ

def show_question_page(planet_name, selected_option, question, answer_options, correct_answer):
    for widget in root.winfo_children():
        widget.destroy()
    
    bg_image = tk.Label(root, image=grid_image_path)
    bg_image.place(relheight=1, relwidth=1)

    title_label = tk.Label(root, text=question, font=('Gill Sans Ultra Bold', 18), fg='white', bg='#711adf', wraplength=500)
    title_label.pack(pady=20)

    global buttons
    buttons = []  # IniÈ›ializÄƒm lista de butoane Ã®nainte de crearea lor

    for answer in answer_options:
        btn = tk.Button(root, text=answer, font=('Gill Sans Ultra Bold', 17), fg='white', bg='#180451', wraplength=500, anchor="w")
        btn.config(command=lambda a=answer, b=btn: handle_answer(a, b, planet_name, selected_option, correct_answer))
        btn.pack(fill="both", expand=True, padx=10, pady=5)
        buttons.append(btn)  # AdÄƒugÄƒm fiecare buton Ã®n listÄƒ

    # Buton "ÃŽnapoi" care revine la pagina de exerciÈ›ii
    back_button = tk.Button(root, text="Undo", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#180451',
                            command=lambda: show_new_options_page(planet_name, selected_option))
    back_button.pack(pady=20)


questions_python_b = [
    "Cum declari o funcÈ›ie Ã®n Python?",
    "Cum citeÈ™ti un fiÈ™ier Ã®n Python?",
    "Cum iterÄƒm peste o listÄƒ folosind list comprehension?",
    "Cum creezi o clasÄƒ Ã®n Python?",
    "Cum verifici dacÄƒ un element existÄƒ Ã®ntr-un dicÈ›ionar?",
    "Cum foloseÈ™ti `try-except` pentru gestionarea erorilor?",
    "Cum sortezi o listÄƒ Ã®n Python?"
]

answers_python_b = [
    ["def my_function():\n    print('Hello!')", "function my_function():\n    print('Hello!')", "def myFunction() print('Hello!')", "fun my_function():\n    print('Hello!')"],
    ["with open('file.txt', 'r') as f:\n    data = f.read()", "file = open('file.txt', 'r')\n    file.read()", "open('file.txt', 'read')", "readfile('file.txt')"],
    ["[x**2 for x in range(10)]", "for x in range(10):\n    x**2", "[for x in range(10): x**2]", "map(lambda x: x**2, range(10))"],
    ["class MyClass:\n    def __init__(self):\n        self.name = 'Example'", "def MyClass:\n    self.name = 'Example'", "new Class MyClass:\n    name = 'Example'", "class = MyClass()"],
    ["if 'key' in my_dict:", "my_dict.has_key('key')", "my_dict.contains('key')", "my_dict.find('key')"],
    ["try:\n    x = int(input('NumÄƒr:'))\nexcept ValueError:\n    print('Eroare!')", "try x = int(input('NumÄƒr')) except ValueError: print('Eroare!')", "except ValueError:\n    x = int(input('NumÄƒr'))", "catch ValueError:\n    x = int(input('NumÄƒr'))"],
    ["sorted(my_list)", "my_list.sort()", "sort(my_list)", "my_list.sorted()"]
]

correct_answers_python_b = [
    "def my_function():\n    print('Hello!')",
    "with open('file.txt', 'r') as f:\n    data = f.read()",
    "[x**2 for x in range(10)]",
    "class MyClass:\n    def __init__(self):\n        self.name = 'Example'",
    "if 'key' in my_dict:",
    "try:\n    x = int(input('NumÄƒr:'))\nexcept ValueError:\n    print('Eroare!')",
    "sorted(my_list)"
]

  # TestÄƒm Ã®n consolÄƒ dacÄƒ se transmit
questions_python_c = [
    "ÃŽn ce linie apare eroarea de indentare?",
    "Unde este eroarea de tip?",
    "Pe ce linie se aflÄƒ eroarea de atribuÈ›ie?",
    "Unde este eroarea de import?",
    "Pe ce linie este eroarea de index?",
    "Unde este eroarea de sintaxÄƒ?",
    "Pe ce linie este eroarea de acces la fiÈ™ier?"
]

code_samples_python_c = [
    "def my_function():\nprint('Hello!')\n  print('Indentation Error!')",
    "x = 'text' + 5\nprint(x)",
    "a, b = (1, 2, 3)\nprint(a, b)",
    "import non_existent_module\nprint('This should fail')",
    "my_list = [1, 2, 3]\nprint(my_list[5])",
    "print('Hello'\nprint('World')",
    "with open('missing_file.txt', 'r') as f:\n    data = f.read()"
]

answers_python_c = [
    ["Linia 2", "Linia 3", "Linia 1", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 2", "Linia 3", "Linia 1", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"],
    ["Linia 1", "Linia 2", "Linia 3", "Nicio eroare"]
]

correct_answers_python_c = [
    "Linia 2",
    "Linia 1",
    "Linia 1",
    "Linia 1",
    "Linia 2",
    "Linia 1",
    "Linia 1"
]
def handle_answer(selected_answer, button, planet_name, selected_option, correct_answer):
    global user_progress, buttons  # Acces la variabilele globale
    
    for btn in buttons:
        btn.config(state="disabled")
    if selected_answer == correct_answer:
        button.config(bg="green")
        
        # ContorizÄƒm rÄƒspunsul corect
        if selected_option not in user_progress:
            user_progress[selected_option] = {}
        if planet_name not in user_progress[selected_option]:
            user_progress[selected_option][planet_name] = 0
        
        user_progress[selected_option][planet_name] += 1  # IncrementÄƒm numÄƒrul de rÄƒspunsuri corecte
        save_progress()  # SalvÄƒm progresul utilizatorului

        play_question_video(r"C:\Users\Adriana\infoeducatie.2-1\WhatsApp Video 2025-05-17 at 22.04.13_3d19574a.mp4", show_question_page, planet_name, selected_option)
    else:
        button.config(bg="red")
        play_question_video(r"C:\Users\Adriana\infoeducatie.2-1\WhatsApp Video 2025-05-17 at 22.12.34_8b843c0c.mp4", show_question_page, planet_name, selected_option)
       
def show_question_page_with_code(planet_name, selected_option,question, code_sample, answer_options, correct_answer):
    """AfiÈ™eazÄƒ codul È™i permite utilizatorului sÄƒ aleagÄƒ unde este eroarea."""
    for widget in root.winfo_children():
        widget.destroy()
    bg_image = tk.Label(root, image=grid_image_path)
    bg_image.place(relheight=1, relwidth=1)

    title_label = tk.Label(root, text=question, font=('Gill Sans Ultra Bold', 18), fg='white', bg='#711adf', wraplength=500)
    title_label.pack(pady=20)

    code_label = tk.Label(root, text=code_sample, font=('Courier', 14), fg='white', bg='#180451', justify="left",wraplength=500, anchor="w")
    code_label.pack(fill="both", expand=True, padx=10, pady=5)
    global buttons
    buttons = []
    for answer in answer_options:
        btn = tk.Button(root, text=answer, font=('Gill Sans Ultra Bold', 15), fg='white', bg='#180451',wraplength=500, anchor="w")
        btn.config(command=lambda a=answer, b=btn: handle_answer(a, b, planet_name, selected_option, correct_answer))
        btn.pack(fill="both", expand=True, padx=10, pady=5)
        buttons.append(btn)

    back_button = tk.Button(root, text="Undo", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#180451', command=lambda: show_new_options_page(planet_name, selected_option))
    back_button.pack(pady=20)


def choose_profile_picture():
    global profile_label  # Referim profile_label
    # Permite utilizatorului sÄƒ selecteze un fiÈ™ier imagine
    file_path = filedialog.askopenfilename(title="Choose a Profile Picture", filetypes=[("Image Files", "*.png;*.jpg;*.jpeg")])

    if file_path:
        try:
            # ÃŽncarcÄƒ imaginea selectatÄƒ
            profile_picture = Image.open(file_path).convert("RGBA")  # Convertim Ã®n format RGBA
            
            # CreÄƒm o mascÄƒ circularÄƒ
            mask = Image.new("L", profile_picture.size, 0)
            draw = ImageDraw.Draw(mask)
            draw.ellipse((0, 0, profile_picture.size[0], profile_picture.size[1]), fill=255)
            
            # AplicÄƒm masca circularÄƒ
            circular_profile = Image.new("RGBA", profile_picture.size)
            circular_profile.paste(profile_picture, (0, 0), mask)
            
            # RedimensionÄƒm imaginea rotundÄƒ
            circular_profile = circular_profile.resize((100, 100))  # Redimensionare (opÈ›ional)
            profile_picture_tk = ImageTk.PhotoImage(circular_profile)

            # AfiÈ™eazÄƒ imaginea rotundÄƒ Ã®n fereastra de "Settings"
            profile_label.config(image=profile_picture_tk)
            profile_label.image = profile_picture_tk
            
            user_data["profile_picture"] = file_path  # Save the file path
            save_user_data(user_data)  # SalveazÄƒ referinÈ›a pentru a evita garbage collection
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load image: {e}")

def remove_profile_picture():
    global profile_label
    profile_label.config(image="", text="No profile picture selected")
    user_data.pop("profile_picture", None)  # Remove profile picture from user data
    save_user_data(user_data)
def open_settings_window():
    global user_input  # Reference the username variable
    global user_mail
    global profile_label
    user_data = load_user_data()  # AdÄƒugat pentru acces la datele utilizatorului

    # Create a new top-level window for settings
    settings_window = tk.Toplevel(root)
    settings_window.geometry('200x400')  # Small vertical window dimensions
    settings_window.title("Settings")
    settings_window.configure(bg='#711adf')  # Background color

    # Add content to the settings window
    label = tk.Label(settings_window, text="Settings", font=('Gill Sans Ultra Bold', 20), fg='#1b219d', bg='#711adf')
    label.pack(pady=20)

    # Display username and email
    username_label = tk.Label(settings_window, text=f"Username: {user_input}", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#711adf')
    username_label.pack(pady=10)
    email_label = tk.Label(settings_window, text=f"E-mail: {user_mail}", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#711adf')
    email_label.pack(pady=30)
    
    # Profile picture label
    profile_label = tk.Label(settings_window, bg='#711adf', text="No profile picture selected")
    profile_label.pack(pady=20)
    
    if "profile_picture" in user_data:
        try:
            profile_picture = Image.open(user_data["profile_picture"]).convert("RGBA")
            mask = Image.new("L", profile_picture.size, 0)
            draw = ImageDraw.Draw(mask)
            draw.ellipse((0, 0, profile_picture.size[0], profile_picture.size[1]), fill=255)
            circular_profile = Image.new("RGBA", profile_picture.size)
            circular_profile.paste(profile_picture, (0, 0), mask)
            circular_profile = circular_profile.resize((100, 100))
            profile_picture_tk = ImageTk.PhotoImage(circular_profile)

            # Display profile picture
            profile_label.config(image=profile_picture_tk, text="")
            profile_label.image = profile_picture_tk
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load saved image: {e}")
    # Button to choose profile picture
    choose_picture_button = tk.Button(
        settings_window,
        text="Choose Profile Picture",
        font=('Gill Sans Ultra Bold', 15),
        fg='white',
        bg='#180451',
        command=choose_profile_picture
    )
    choose_picture_button.pack(pady=20)

    remove_picture_button = tk.Button(
        settings_window,
        text="Remove Profile Picture",
        font=('Gill Sans Ultra Bold', 15),
        fg='white',
        bg='#180451',
        command=remove_profile_picture
    )
    remove_picture_button.pack(pady=20)


settings_button = tk.Button(
    root,
    text="Settings",
    font=('Gill Sans Ultra Bold', 15),
    fg='white',
    bg='#180451',
    command=open_settings_window
)
settings_button.pack(pady=20)
def save_credentials(username, password, email):
    file_path = r"C:\Users\Adriana\Desktop\grid\credentials.txt"
    try:
       with open(file_path, "a") as file:
        file.write(f"Username: {username}, Email: {email}, Password: {password}\n")
       print("Parola a fost salvatÄƒ cu succes!")  # Mesaj de confirmare
    except Exception as e:
       print(f"Eroare la salvarea parolei: {e}") 
 # Mesaj de eroare
def send_email_confirmation(user_email):
    sender_email = "your-email@example.com"
    sender_password = "your-email-password"

    msg = MIMEText(f"Hello {user_email}, your account has been successfully created!")
    msg["Subject"] = "Confirmation Email"
    msg["From"] = sender_email
    msg["To"] = user_email

    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(sender_email, sender_password)
            server.sendmail(sender_email, user_email, msg.as_string())
        print("Email sent successfully!")
    except Exception as e:
        print(f"Error sending email: {e}")


def open_profile_window():
    global profile_label  # Referim profile_label

    # Creare fereastrÄƒ nouÄƒ pentru profil
    profile_window = tk.Toplevel(root)
    profile_window.geometry('300x400')  # Dimensiuni ajustate
    profile_window.title("Profile")
    profile_window.configure(bg='#711adf')  # Culoare de fundal

    # AdÄƒugare etichetÄƒ pentru titlu
    title_label = tk.Label(profile_window, text="Profile", font=('Gill Sans Ultra Bold', 20), fg='#1b219d', bg='#711adf')
    title_label.pack(pady=20)

    # AfiÈ™are poza de profil
    profile_display_label = tk.Label(profile_window, bg='#711adf', text="No profile picture selected")
    profile_display_label.pack(pady=20)

    if "profile_picture" in user_data:
        try:
            # ÃŽncÄƒrcare poza de profil salvatÄƒ
            profile_picture = Image.open(user_data["profile_picture"]).convert("RGBA")
            mask = Image.new("L", profile_picture.size, 0)
            draw = ImageDraw.Draw(mask)
            draw.ellipse((0, 0, profile_picture.size[0], profile_picture.size[1]), fill=255)
            circular_profile = Image.new("RGBA", profile_picture.size)
            circular_profile.paste(profile_picture, (0, 0), mask)
            circular_profile = circular_profile.resize((100, 100))  # Redimensionare
            profile_picture_tk = ImageTk.PhotoImage(circular_profile)

            # AfiÈ™are poza de profil Ã®n fereastrÄƒ
            profile_display_label.config(image=profile_picture_tk, text="")
            profile_display_label.image = profile_picture_tk  # PÄƒstrare referinÈ›Äƒ pentru a evita garbage collection
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load saved image: {e}")

    # AfiÈ™are username È™i e-mail
    username_label = tk.Label(profile_window, text=f"Username: {user_input}", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#711adf')
    username_label.pack(pady=10)
    email_label = tk.Label(profile_window, text=f"E-mail: {user_mail}", font=('Gill Sans Ultra Bold', 15), fg='white', bg='#711adf')
    email_label.pack(pady=10)

# AdaugÄƒ butonul "Profile" Ã®n fereastra principalÄƒ
button_profile = tk.Button(
    root,
    text="Profile",
    font=('Gill Sans Ultra Bold', 12),
    fg='white',
    bg='#180451',
    command=open_profile_window
)
button_profile.pack(side=tk.LEFT, padx=50, pady=5)

grid_image_path = PhotoImage(file=r"C:\Users\Adriana\Desktop\grid\WhatsApp Image 2025-04-05 at 22.02.28_9d96eb52.png")  # Replace with your grid background path
play_video()

root.mainloop()
